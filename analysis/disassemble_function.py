#!/usr/bin/env python3
"""
Disassemble and annotate a function from the FSN binary.

Automates Steps 2-4 of the Decompilation Procedure:
- Auto-detect function boundaries (jr ra or next prologue)
- Extract disassembly for the complete function
- Resolve GP offsets to symbol names
- Output annotated assembly with metadata

Usage:
    python3 analysis/disassemble_function.py FUN_00422f58
    python3 analysis/disassemble_function.py 0x00422f58
    python3 analysis/disassemble_function.py draw_warp_directory
    python3 analysis/disassemble_function.py FUN_00422f58 --size 0x800 --no-auto

Features:
- Auto-detects function end via 'jr ra' (return) or next 'addiu sp,sp,-N' (prologue)
- Scans up to 0x2000 bytes by default
- Resolves GP offsets to known symbols (functions, data, IrisGL calls)
- Outputs header with address, size, and detection method
"""

import argparse
import os
import re
import struct
import subprocess
import sys
from pathlib import Path

# Binary layout constants
BINARY_PATH = "fsn.original"
GP = 0x1001db30
GOT_START = 0x10015b40
GOT_FILE_OFFSET = 0x51b40
GOT_SIZE = 0xa60
TEXT_START = 0x00409440
TEXT_END = 0x0043b7b0

# Default function size to disassemble (used as initial scan if --auto)
DEFAULT_SIZE = 0x400
MAX_FUNCTION_SIZE = 0x2000  # Safety limit for auto-detection

# Known IrisGL and library function GP offsets (from analysis/docs)
# These are external functions that resolve at runtime
KNOWN_EXTERNAL_OFFSETS = {
    # IrisGL drawing
    -32240: "rect",       # 0x8210
    -32288: "rectf",      # 0x8240
    -32192: "v3f",        # 0x81c0
    -31644: "cpack",      # 0x7b9c
    -31560: "pushmatrix", # 0x7b48
    -31528: "popmatrix",  # 0x7b28
    -31584: "translate",  # 0x7b60
    -31596: "scale",      # 0x7b6c
    -31592: "rotate",     # 0x7b68
    -31564: "czclear",    # 0x7b5c
    -31572: "swapbuffers", # 0x7b54
    -31944: "zbuffer",    # 0x7cc8 - z-buffer enable
    -32196: "bgnline",    # 0x7dc4
    -32228: "endline",    # 0x7de4
    -31620: "linewidth",  # 0x7b84
    -31032: "draw_directories",  # internal
    -30172: "fsn_resources",     # data
    -30340: "curcontext",        # data
    -30348: "boxDir",            # data
    # Math
    -32116: "fcos",
    -32112: "fsin",
    -32108: "fsqrt",
}


def load_dynamic_symbols(binary_path: str) -> dict:
    """Load dynamic symbols from binary.

    Returns dict mapping address → symbol name.
    Includes both defined symbols and PLT stubs for external functions.
    """
    result = subprocess.run(
        ['mips-linux-gnu-objdump', '-T', binary_path],
        capture_output=True, text=True
    )
    symbols = {}
    for line in result.stdout.split('\n'):
        parts = line.split()
        if len(parts) >= 2:
            try:
                addr = int(parts[0], 16)
                name = parts[-1]
                if addr:
                    symbols[addr] = name
            except ValueError:
                continue
    return symbols


def load_plt_mapping(binary_path: str) -> dict:
    """Build mapping from PLT stub addresses to symbol names.

    MIPS PLT stubs are at sequential addresses for external functions.
    """
    result = subprocess.run(
        ['mips-linux-gnu-objdump', '-T', binary_path],
        capture_output=True, text=True
    )
    plt_map = {}
    for line in result.stdout.split('\n'):
        # Parse: 0040a460      DF *UND*	00000000 pushmatrix
        if '*UND*' in line:
            parts = line.split()
            if len(parts) >= 2:
                try:
                    addr = int(parts[0], 16)
                    name = parts[-1]
                    if addr:
                        plt_map[addr] = name
                except ValueError:
                    continue
    return plt_map


def read_got_entry(binary_path: str, gp_offset: int) -> tuple:
    """Read a 4-byte big-endian value from GOT at GP + offset."""
    got_addr = GP + gp_offset
    if got_addr < GOT_START or got_addr >= GOT_START + GOT_SIZE:
        return None, got_addr

    file_offset = GOT_FILE_OFFSET + (got_addr - GOT_START)

    with open(binary_path, 'rb') as f:
        f.seek(file_offset)
        data = f.read(4)
        if len(data) < 4:
            return None, got_addr
        value = struct.unpack('>I', data)[0]
        return value, got_addr


def load_gp_mapping_file(mapping_file: str) -> dict:
    """Load GP offset → symbol mapping from GP_MAPPING.md file.

    This file is generated by resolve_indirect_calls.py and contains
    the complete mapping including external library functions.
    """
    mapping = {}
    if not os.path.exists(mapping_file):
        return mapping

    with open(mapping_file, 'r') as f:
        for line in f:
            # Parse: | `-0x76ec` | `0x0043b79c` | `__istart` |
            match = re.match(r'\|\s*`(-?0x[0-9a-fA-F]+)`\s*\|\s*`[^`]+`\s*\|\s*`([^`]+)`\s*\|', line)
            if match:
                offset_hex, symbol = match.groups()
                offset = int(offset_hex, 16)
                mapping[offset] = symbol

    return mapping


def build_gp_mapping(binary_path: str, symbols: dict) -> dict:
    """Build GP offset → symbol mapping for offsets found in assembly.

    Combines:
    1. Known external function offsets (IrisGL, libc, etc.)
    2. GP_MAPPING.md file (if exists)
    3. GOT reading fallback
    """
    # Start with known external offsets
    mapping = dict(KNOWN_EXTERNAL_OFFSETS)

    # Try to load from existing mapping file
    mapping_file = Path("fsn_original.exploded.cleanup/GP_MAPPING.md")
    if mapping_file.exists():
        file_mapping = load_gp_mapping_file(str(mapping_file))
        # Merge, preferring known externals over EXTERNAL_0x... labels
        for offset, symbol in file_mapping.items():
            if offset not in mapping or not symbol.startswith('EXTERNAL_'):
                if not symbol.startswith('EXTERNAL_'):
                    mapping[offset] = symbol

    # Also scan GOT for any missed entries
    for offset in range(-32768, 0, 4):
        if offset in mapping:
            continue  # Already have this offset

        value, _ = read_got_entry(binary_path, offset)
        if value is None:
            continue

        if value in symbols:
            mapping[offset] = symbols[value]
        elif TEXT_START <= value <= TEXT_END:
            mapping[offset] = f"FUN_{value:08x}"
        elif 0x10000000 <= value <= 0x10020000:
            mapping[offset] = f"DAT_{value:08x}"

    return mapping


def find_function_address(func_name: str, binary_path: str) -> int:
    """Find function address from name or address string."""
    # Direct hex address
    if func_name.startswith('0x'):
        return int(func_name, 16)

    # FUN_ format
    if func_name.startswith('FUN_'):
        return int(func_name[4:], 16)

    # Search in dynamic symbols
    result = subprocess.run(
        ['mips-linux-gnu-objdump', '-T', binary_path],
        capture_output=True, text=True
    )
    for line in result.stdout.split('\n'):
        if func_name in line:
            parts = line.split()
            if parts:
                try:
                    return int(parts[0], 16)
                except ValueError:
                    continue

    # Search in .rodata strings (function names embedded in binary)
    result = subprocess.run(
        ['strings', '-t', 'x', binary_path],
        capture_output=True, text=True
    )
    for line in result.stdout.split('\n'):
        if func_name in line:
            print(f"Found string '{func_name}' at offset: {line.split()[0]}", file=sys.stderr)

    # Search in exploded cleanup files
    cleanup_dir = Path("fsn_original.exploded.cleanup")
    if cleanup_dir.exists():
        for f in cleanup_dir.glob("*.c"):
            if func_name.lower() in f.stem.lower():
                # Try to extract address from file content
                content = f.read_text()
                match = re.search(r'FUN_([0-9a-fA-F]{8})', content)
                if match:
                    return int(match.group(1), 16)

    return None


def extract_disassembly(binary_path: str, start_addr: int, size: int) -> str:
    """Extract disassembly for address range."""
    end_addr = start_addr + size
    result = subprocess.run(
        ['mips-linux-gnu-objdump', '-d',
         f'--start-address=0x{start_addr:08x}',
         f'--stop-address=0x{end_addr:08x}',
         binary_path],
        capture_output=True, text=True
    )
    return result.stdout


def decode_float_constant(high_bits: int, low_bits: int = 0) -> str:
    """Decode IEEE 754 single-precision float from register load pattern."""
    import struct
    value = (high_bits << 16) | low_bits
    try:
        f = struct.unpack('>f', struct.pack('>I', value))[0]
        # Format nicely
        if f == int(f):
            return f"{f:.1f}f"
        else:
            return f"{f}f"
    except:
        return None


# Common float constants for quick reference
FLOAT_CONSTANTS = {
    0x3f800000: "1.0f",
    0x40000000: "2.0f",
    0x40400000: "3.0f",
    0x3f000000: "0.5f",
    0x3e800000: "0.25f",
    0xbf800000: "-1.0f",
    0xbf000000: "-0.5f",
    0x00000000: "0.0f",
    0x3f400000: "0.75f",
    0x3fc00000: "1.5f",
}


def annotate_assembly(asm_text: str, gp_mapping: dict) -> tuple:
    """
    Add comprehensive annotations to assembly.

    Returns (annotated_text, analysis_dict) where analysis_dict contains:
    - calls: list of (address, function_name) tuples
    - gp_refs: set of GP symbols referenced
    - float_loads: list of (address, value) tuples
    """
    lines = []
    analysis = {
        'calls': [],
        'gp_refs': set(),
        'float_loads': [],
        'igl_calls': [],  # IrisGL calls specifically
    }

    # Track register state for call resolution
    pending_t9_symbol = None
    pending_t9_addr = None
    pending_lui_reg = {}  # reg -> (addr, high_bits)

    for line in asm_text.split('\n'):
        annotation = None

        # Parse address from line
        addr_match = re.match(r'\s*([0-9a-fA-F]+):', line)
        current_addr = int(addr_match.group(1), 16) if addr_match else None

        # Look for GP-relative access: lw/sw rN,OFFSET(gp)
        gp_match = re.search(r'(lw|sw)\s+(\w+),(-?\d+)\(gp\)', line)
        if gp_match:
            op, reg, offset_str = gp_match.groups()
            offset = int(offset_str)
            if offset in gp_mapping:
                symbol = gp_mapping[offset]
                annotation = symbol
                analysis['gp_refs'].add(symbol)

                # Track t9 loads for call resolution
                if reg == 't9' and op == 'lw':
                    pending_t9_symbol = symbol
                    pending_t9_addr = current_addr

        # Look for jalr t9 (function call via t9)
        if 'jalr\tt9' in line or 'jalr\t$t9' in line:
            if pending_t9_symbol:
                annotation = f"call {pending_t9_symbol}"
                analysis['calls'].append((current_addr, pending_t9_symbol))

                # Track IrisGL calls specifically
                igl_funcs = {'rect', 'rectf', 'v3f', 'bgnline', 'endline',
                            'pushmatrix', 'popmatrix', 'translate', 'scale',
                            'rotate', 'cpack', 'linewidth', 'czclear', 'mmode',
                            'perspective', 'lookat', 'bgnclosedline', 'endclosedline'}
                if pending_t9_symbol.lower() in igl_funcs:
                    analysis['igl_calls'].append((current_addr, pending_t9_symbol))

                pending_t9_symbol = None

        # Look for lui (load upper immediate) - start of float constant or address
        lui_match = re.search(r'lui\s+(\w+),0x([0-9a-fA-F]+)', line)
        if lui_match:
            reg, high_hex = lui_match.groups()
            high_bits = int(high_hex, 16)
            pending_lui_reg[reg] = (current_addr, high_bits)

            # Check if this alone is a recognizable float (low bits = 0)
            full_val = high_bits << 16
            if full_val in FLOAT_CONSTANTS:
                annotation = FLOAT_CONSTANTS[full_val]
                analysis['float_loads'].append((current_addr, full_val, FLOAT_CONSTANTS[full_val]))

        # Look for mtc1 (move to coprocessor 1 - load float register)
        mtc1_match = re.search(r'mtc1\s+(\w+),\$f(\d+)', line)
        if mtc1_match:
            src_reg, fp_reg = mtc1_match.groups()
            if src_reg in pending_lui_reg:
                lui_addr, high_bits = pending_lui_reg[src_reg]
                full_val = high_bits << 16  # Assume low bits are 0
                if full_val in FLOAT_CONSTANTS:
                    annotation = f"$f{fp_reg} = {FLOAT_CONSTANTS[full_val]}"
                else:
                    decoded = decode_float_constant(high_bits)
                    if decoded:
                        annotation = f"$f{fp_reg} = {decoded}"
                        analysis['float_loads'].append((current_addr, full_val, decoded))

        # Look for ori after lui (complete 32-bit constant)
        ori_match = re.search(r'ori\s+(\w+),(\w+),0x([0-9a-fA-F]+)', line)
        if ori_match:
            dst_reg, src_reg, low_hex = ori_match.groups()
            if src_reg in pending_lui_reg:
                lui_addr, high_bits = pending_lui_reg[src_reg]
                low_bits = int(low_hex, 16)
                full_val = (high_bits << 16) | low_bits
                if full_val in FLOAT_CONSTANTS:
                    annotation = FLOAT_CONSTANTS[full_val]

        # Add annotation to line
        if annotation:
            if '#' in line:
                line = line.rstrip() + f"  [{annotation}]"
            else:
                line = line.rstrip() + f"  # {annotation}"

        lines.append(line)

    return '\n'.join(lines), analysis


def format_analysis_summary(analysis: dict, func_name: str) -> str:
    """Format the analysis results as a readable summary."""
    lines = []
    lines.append("")
    lines.append("=" * 70)
    lines.append(f"ANALYSIS SUMMARY: {func_name}")
    lines.append("=" * 70)

    # Function calls
    if analysis['calls']:
        lines.append("")
        lines.append("FUNCTION CALLS:")
        lines.append("-" * 40)
        # Group by function name and count
        call_counts = {}
        for addr, name in analysis['calls']:
            call_counts[name] = call_counts.get(name, 0) + 1
        for name, count in sorted(call_counts.items()):
            if count > 1:
                lines.append(f"  {name} ({count}x)")
            else:
                lines.append(f"  {name}")

    # IrisGL calls specifically
    if analysis['igl_calls']:
        lines.append("")
        lines.append("IRISGL CALLS (with addresses):")
        lines.append("-" * 40)
        for addr, name in analysis['igl_calls']:
            lines.append(f"  0x{addr:08x}: {name}")

    # Float constants
    if analysis['float_loads']:
        lines.append("")
        lines.append("FLOAT CONSTANTS LOADED:")
        lines.append("-" * 40)
        seen = set()
        for addr, val, decoded in analysis['float_loads']:
            key = (val, decoded)
            if key not in seen:
                lines.append(f"  0x{val:08x} = {decoded}")
                seen.add(key)

    # GP references
    if analysis['gp_refs']:
        lines.append("")
        lines.append("GP SYMBOL REFERENCES:")
        lines.append("-" * 40)
        for ref in sorted(analysis['gp_refs']):
            lines.append(f"  {ref}")

    lines.append("")
    lines.append("=" * 70)

    return '\n'.join(lines)


def find_function_end(asm_text: str, start_addr: int) -> tuple:
    """
    Find function end by looking for:
    1. jr ra (return instruction) - include delay slot (+8 bytes)
    2. Next function's prologue: addiu sp,sp,-N (negative stack allocation)

    MIPS PIC function prologue pattern:
      lui gp, HIGH        # Set up GP for PIC
      addiu gp, gp, LOW
      addu gp, gp, t9
      addiu sp, sp, -N    # Stack frame allocation (THIS function)
      ...                 # Function body
      jr ra               # Return

    We detect end by finding either:
    - jr ra (return) - function completed
    - Second addiu sp,sp,-N - next function's prologue

    Returns (end_addr, detection_method) tuple.
    """
    lines = asm_text.split('\n')
    last_addr = start_addr
    stack_alloc_seen = False  # Track if we've seen THIS function's stack allocation

    for line in lines:
        # Parse address
        match = re.match(r'\s*([0-9a-fA-F]+):', line)
        if match:
            addr = int(match.group(1), 16)

            # Skip until we're past the start address
            if addr < start_addr:
                continue

            last_addr = addr

            # Look for return instruction (most common end)
            if 'jr\tra' in line or 'jr\t$ra' in line:
                # Include the delay slot (+4) and align to next instruction (+4)
                return addr + 8, "jr ra"

            # Look for stack frame allocation: addiu sp,sp,-N
            prologue_match = re.search(r'addiu\s+sp,sp,-\d+', line)
            if prologue_match:
                if stack_alloc_seen:
                    # Second stack allocation = next function's prologue
                    return addr, "next function prologue"
                else:
                    # First stack allocation = this function's prologue
                    stack_alloc_seen = True

    return last_addr, "end of scan"


def main():
    parser = argparse.ArgumentParser(
        description='Disassemble and annotate a function from FSN binary'
    )
    parser.add_argument('function', help='Function name (FUN_00422f58) or address (0x00422f58)')
    parser.add_argument('--size', type=lambda x: int(x, 0), default=None,
                       help=f'Size to disassemble (default: auto-detect up to 0x{MAX_FUNCTION_SIZE:x})')
    parser.add_argument('--auto', '-a', action='store_true', default=True,
                       help='Auto-detect function end by finding jr ra (default: True)')
    parser.add_argument('--no-auto', action='store_false', dest='auto',
                       help='Disable auto-detection, use fixed size')
    parser.add_argument('--output', '-o', default='analysis',
                       help='Output directory (default: analysis)')
    parser.add_argument('--binary', '-b', default=BINARY_PATH,
                       help=f'Binary path (default: {BINARY_PATH})')

    args = parser.parse_args()

    # Find function address
    addr = find_function_address(args.function, args.binary)
    if addr is None:
        print(f"Error: Could not find function '{args.function}'", file=sys.stderr)
        print("\nTry:", file=sys.stderr)
        print(f"  - Direct address: python3 {sys.argv[0]} 0x00422f58", file=sys.stderr)
        print(f"  - FUN_ format: python3 {sys.argv[0]} FUN_00422f58", file=sys.stderr)
        sys.exit(1)

    print(f"Function address: 0x{addr:08x}", file=sys.stderr)

    # Load symbols and build GP mapping
    print("Loading symbols...", file=sys.stderr)
    symbols = load_dynamic_symbols(args.binary)
    print(f"Found {len(symbols)} dynamic symbols", file=sys.stderr)

    print("Building GP offset mapping...", file=sys.stderr)
    gp_mapping = build_gp_mapping(args.binary, symbols)
    print(f"Mapped {len(gp_mapping)} GP offsets", file=sys.stderr)

    # Determine disassembly size
    if args.size is not None:
        # Explicit size specified
        disasm_size = args.size
        print(f"Extracting disassembly (0x{disasm_size:x} bytes, fixed size)...", file=sys.stderr)
    elif args.auto:
        # Auto-detect: extract large chunk and find function end
        disasm_size = MAX_FUNCTION_SIZE
        print(f"Extracting disassembly (up to 0x{disasm_size:x} bytes, auto-detect)...", file=sys.stderr)
    else:
        # No auto, no explicit size - use default
        disasm_size = DEFAULT_SIZE
        print(f"Extracting disassembly (0x{disasm_size:x} bytes, default)...", file=sys.stderr)

    asm = extract_disassembly(args.binary, addr, disasm_size)

    # Auto-detect function end if enabled
    actual_size = disasm_size
    detection_method = "fixed size"
    if args.auto and args.size is None:
        end_addr, detection_method = find_function_end(asm, addr)
        if end_addr > addr:
            actual_size = end_addr - addr
            print(f"Auto-detected function end at 0x{end_addr:08x} (size: 0x{actual_size:x}) via {detection_method}", file=sys.stderr)
            # Re-extract with exact size for cleaner output
            asm = extract_disassembly(args.binary, addr, actual_size)
        else:
            print(f"Warning: Could not find function end, using full scan (0x{disasm_size:x} bytes)", file=sys.stderr)

    # Determine output filename
    if args.function.startswith('FUN_') or args.function.startswith('0x'):
        func_name = f"FUN_{addr:08x}"
    else:
        func_name = args.function

    # Annotate and analyze
    print("Annotating and analyzing...", file=sys.stderr)
    annotated, analysis = annotate_assembly(asm, gp_mapping)

    # Generate analysis summary
    summary = format_analysis_summary(analysis, func_name)

    output_path = Path(args.output) / f"{func_name}.annotated.asm"
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, 'w') as f:
        f.write(f"# Disassembly of {func_name}\n")
        f.write(f"# Address: 0x{addr:08x}\n")
        f.write(f"# End: 0x{addr + actual_size:08x}\n")
        f.write(f"# Size: 0x{actual_size:x} ({actual_size} bytes)\n")
        f.write(f"# Detection: {detection_method}\n")
        f.write(f"# GP = 0x{GP:08x}\n")
        f.write("#\n")
        f.write("# Annotations: GP offsets, function calls, float constants\n")
        f.write("# See docs/DECOMPILATION_PROCEDURE.md for analysis workflow.\n")
        f.write("#\n\n")
        f.write(annotated)
        f.write("\n")
        f.write(summary)

    print(f"\nOutput: {output_path}", file=sys.stderr)

    # Print summary to stderr as well
    print(summary, file=sys.stderr)


if __name__ == '__main__':
    main()
